import { Sequelize } from 'sequelize';

/**
 * Lazy MySQL connection for <%= schemaNames.pascalCase %> entity
 * Implements lazy loading pattern - connects only when first accessed
 */
class <%= schemaNames.pascalCase %>MySqlConnection {
  private static instance: <%= schemaNames.pascalCase %>MySqlConnection;
  private _sequelize: Sequelize | null = null;
  private _isConnecting = false;
  private _connectionPromise: Promise<Sequelize> | null = null;

  private constructor() {}

  static getInstance(): <%= schemaNames.pascalCase %>MySqlConnection {
    if (!<%= schemaNames.pascalCase %>MySqlConnection.instance) {
      <%= schemaNames.pascalCase %>MySqlConnection.instance = new <%= schemaNames.pascalCase %>MySqlConnection();
    }
    return <%= schemaNames.pascalCase %>MySqlConnection.instance;
  }

  /**
   * Get MySQL connection (lazy initialization)
   */
  async getConnection(): Promise<Sequelize> {
    if (this._sequelize) {
      return this._sequelize;
    }

    if (this._isConnecting && this._connectionPromise) {
      return this._connectionPromise;
    }

    this._isConnecting = true;
    this._connectionPromise = this.createConnection();
    
    try {
      this._sequelize = await this._connectionPromise;
      this._isConnecting = false;
      return this._sequelize;
    } catch (error) {
      this._isConnecting = false;
      this._connectionPromise = null;
      throw error;
    }
  }

  /**
   * Create new MySQL connection
   */
  private async createConnection(): Promise<Sequelize> {
    const databaseUrl = process.env.<%= envVar %>;
    
    if (!databaseUrl) {
      throw new Error(
        `Environment variable <%= envVar %> is required for <%= schemaNames.pascalCase %> MySQL connection. ` +
        `Example: <%= envVar %>=mysql://user:password@localhost:3306/<%= databaseName %>`
      );
    }

    const sequelize = new Sequelize(databaseUrl, {
      dialect: '<%= dialect %>',
      logging: process.env.NODE_ENV === 'development' ? console.log : false,
      pool: {
        max: 5,
        min: 0,
        acquire: 30000,
        idle: 10000
      },
      retry: {
        max: 3,
        match: [
          /ConnectionError/,
          /ConnectionTimedOutError/,
          /TimeoutError/,
          /SequelizeConnectionError/,
          /SequelizeConnectionRefusedError/,
          /SequelizeHostNotFoundError/,
          /SequelizeHostNotReachableError/,
          /SequelizeInvalidConnectionError/,
          /SequelizeConnectionTimedOutError/
        ]
      }
    });

    // Test the connection
    try {
      await sequelize.authenticate();
      console.log(`‚úÖ <%= schemaNames.pascalCase %> MySQL connection established successfully`);
      
      // Sync database in development
      if (process.env.NODE_ENV === 'development') {
        await sequelize.sync({ alter: true });
        console.log(`‚úÖ <%= schemaNames.pascalCase %> MySQL database synced`);
      }
      
      return sequelize;
    } catch (error) {
      console.error(`‚ùå <%= schemaNames.pascalCase %> MySQL connection failed:`, error);
      throw new Error(`Failed to connect to <%= schemaNames.pascalCase %> MySQL database: ${error}`);
    }
  }

  /**
   * Close the connection
   */
  async close(): Promise<void> {
    if (this._sequelize) {
      await this._sequelize.close();
      this._sequelize = null;
      this._connectionPromise = null;
      console.log(`üîå <%= schemaNames.pascalCase %> MySQL connection closed`);
    }
  }

  /**
   * Check if connected
   */
  isConnected(): boolean {
    return this._sequelize !== null;
  }

  /**
   * Get raw Sequelize instance (for transactions, etc.)
   */
  async getSequelize(): Promise<Sequelize> {
    return this.getConnection();
  }
}

export const <%= schemaNames.camelCase %>MySqlConnection = <%= schemaNames.pascalCase %>MySqlConnection.getInstance();
export default <%= schemaNames.camelCase %>MySqlConnection;
